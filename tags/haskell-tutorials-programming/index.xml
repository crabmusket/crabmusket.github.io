<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>haskell tutorials programming on the crab &amp; musket</title><link>/tags/haskell-tutorials-programming/</link><description>Recent content in haskell tutorials programming on the crab &amp; musket</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 21 Jan 2014 00:00:00 +0000</lastBuildDate><atom:link href="/tags/haskell-tutorials-programming/index.xml" rel="self" type="application/rss+xml"/><item><title>IO: You may say I'm a monad, but I'm not the only one!</title><link>/blog/you-may-say-im-a-monad/</link><pubDate>Tue, 21 Jan 2014 00:00:00 +0000</pubDate><guid>/blog/you-may-say-im-a-monad/</guid><description>One of the things I love about Haskell is its tools for abstracting computation. There are so many different ways to look at a given problem, and new ones are being invented/discovered all the time. Monads are just one abstraction, a popular and important one.
When you&amp;rsquo;re learning Haskell, you&amp;rsquo;re told &amp;lsquo;IO is a monad&amp;rsquo;, and whether or not you understand what that means, you start to see the significance of binding impure values, returning pure ones, using do notation, and so on.</description></item></channel></rss>