<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="ie=edge">
<title>IO: You may say I'm a monad, but I'm not the only one! &mdash; the crab & musket</title>
<meta name=description content>
<meta name=viewport content="width=device-width,initial-scale=1">
<link href=/css/main.css rel=stylesheet>
<meta property="og:url" content="/blog/you-may-say-im-a-monad/">
<meta property="og:type" content="article">
<meta property="og:title" content="IO: You may say I'm a monad, but I'm not the only one!">
<meta property="article:published_time" content="2014-01-21T00:00:00+00:00Z">
<meta name=twitter:card content="summary">
<meta name=twitter:creator content="@crabmusket">
<link rel=webmention href=https://webmention.io/crabmusket.net/webmention>
<link rel=pingback href=https://webmention.io/crabmusket.net/xmlrpc>
<link rel=alternate type=application/rss+xml href=/blog/index.xml title="the crab & musket">
</head>
<body>
<div class=container>
<a href=/blog>
<h1 class=site-title>
<span class=site-title__prefix>the</span>
crab & musket
</h1>
</a>
<hr>
<div class=content>
<div class=post-header>
<h2 class=post-header__title>IO: You may say I'm a monad, but I'm not the only one!</h2>
<span class=post-header__date>January 21, 2014</span>
</div>
<div class=post>
<p>One of the things I love about Haskell is its tools for abstracting computation.
There are so many different ways to look at a given problem, and new ones are being invented/discovered all the time.
Monads are just one abstraction, a popular and important one.</p>
<p>When you&rsquo;re learning Haskell, you&rsquo;re told &lsquo;<code>IO</code> is a monad&rsquo;, and whether or not you understand what that means, you start to see the significance of binding impure values, returning pure ones, using <code>do</code> notation, and so on.
I thought I was a pro at monads after discovering <code>liftM</code>,
but I still hadn&rsquo;t really made the jump to understanding monads <em>in general</em>, rather than as something specific to impure IO operations.
So today we&rsquo;ll take a look at practical uses of the monad-ness of types other than <code>IO</code>: in particular, list and <code>Maybe</code>.
We&rsquo;ll use their <code>Monad</code> instances (as well as their <code>Functor</code> and <code>Applicative</code> instances) to simplify otherwise-gnarly computations.</p>
<p>Speaking of <code>Applicative</code> and <code>Functor</code>, I&rsquo;ll also be introducing some of those other computation abstractions, and showing you the same code using several different styles.
My goal isn&rsquo;t to give you a deep understanding of how these typeclasses work - just an introduction to the different syntax you&rsquo;ll see hopefully a start at understanding how it behaves.</p>
<h2 id=a-quick-review-functors>A quick review: functors</h2>
<p>A concept I&rsquo;ll be referring to a lot in this post is the idea of computing on <em>things in boxes</em>.
This is sort of the idea of the <code>Functor</code> typeclass, and its function <code>fmap</code>.
If you&rsquo;re not familiar with <code>fmap</code>, here&rsquo;s a lightning-fast introduction:</p>
<p>Think of a <code>Maybe Int</code> as a box that might contain an <code>Int</code> and might not.
<code>fmap</code> turns a regular function into a function that looks inside the box first, and doesn&rsquo;t try to apply itself if the box is empty.
So while we can&rsquo;t do this:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=nf>succ</span> <span class=p>(</span><span class=kt>Just</span> <span class=mi>5</span><span class=p>)</span>
</code></pre></div><p>We can do this:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=p>(</span><span class=n>fmap</span> <span class=n>succ</span><span class=p>)</span> <span class=p>(</span><span class=kt>Just</span> <span class=mi>5</span><span class=p>)</span>
</code></pre></div><p>The parentheses around <code>fmap succ</code> aren&rsquo;t necessary, I&rsquo;m just making the point that we&rsquo;re creating a new computation that <code>Just 5</code> is applied to.
The <code>fmap</code> turned <code>succ</code> from a regular function into a function that is <em>box-aware</em>.</p>
<h2 id=maybe-its-fate>Maybe it&rsquo;s fate</h2>
<p>Here&rsquo;s a problem.
Add two <code>Maybe Int</code>s.
Let&rsquo;s pretend we looked these <code>Ints</code> up in a <code>Map</code> or something (where, obviously, they might not exist - hence the <code>Maybe</code> type of <code>Data.Map</code>&rsquo;s lookup functions) and now we want to perform some computation on them, while <em>preserving</em> their <code>Maybe</code>ness.
I.e., if one of these values doesn&rsquo;t exist, we want our computation to return <code>Nothing</code> as well.</p>
<p>Here&rsquo;s a pretty simple, obvious implementation: use <code>case</code> to check whether the values are <code>Just</code> or <code>Nothing</code>!</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=nf>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>z</span> <span class=ow>::</span> <span class=kt>Maybe</span> <span class=kt>Int</span>
<span class=nf>z</span> <span class=ow>=</span> <span class=kr>case</span> <span class=n>x</span> <span class=kr>of</span>
    <span class=kt>Nothing</span> <span class=ow>-&gt;</span> <span class=kt>Nothing</span>
    <span class=kt>Just</span> <span class=n>x&#39;</span> <span class=ow>-&gt;</span> <span class=kr>case</span> <span class=n>y</span> <span class=kr>of</span>
        <span class=kt>Nothing</span> <span class=ow>-&gt;</span> <span class=kt>Nothing</span>
        <span class=kt>Just</span> <span class=n>y&#39;</span> <span class=ow>-&gt;</span> <span class=kt>Just</span> <span class=p>(</span><span class=n>x&#39;</span> <span class=o>+</span> <span class=n>y&#39;</span><span class=p>)</span>
</code></pre></div><p>Easy, right?
Now if either <code>x</code> or <code>y</code> is <code>Nothing</code>, one of the cases will fail and the result, <code>z</code>, will be <code>Nothing</code>.
Otherwise, we&rsquo;ll get a <code>Just</code> value with the added values.</p>
<p>You might feel a bit guilty having written this.
That big nested <code>case</code> is a bit ugly, though not unreadable.
And we can even extend it relatively painlessly by just adding more cascading <code>case</code>s if we want to add, say, three <code>Maybe Int</code>s.
But can we do better?
The answer, as it always is in Haskell, is <em>yes</em>.</p>
<p>(You might be tempted to write a function that uses pattern-matching on <code>Nothing</code> and <code>Just</code> to achieve the same result.
Good try, but we can do <em>even better</em>.)</p>
<h2 id=monadic-style>Monadic style</h2>
<p>Let&rsquo;s make this a monadic computation using <code>do</code> notation.
I&rsquo;ll explain how this works in a minute, but just look at it for now:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=nf>z</span> <span class=ow>=</span> <span class=kr>do</span>
    <span class=n>x&#39;</span> <span class=ow>&lt;-</span> <span class=n>x</span>
    <span class=n>y&#39;</span> <span class=ow>&lt;-</span> <span class=n>y</span>
    <span class=n>return</span> <span class=p>(</span><span class=n>x&#39;</span> <span class=o>+</span> <span class=n>y&#39;</span><span class=p>)</span>
</code></pre></div><p>Note the parallels between this and our <code>case</code> expression - particularly the similarity between <code>Just (x' + y')</code> and <code>return (x' + y')</code>.
But, most stunningly - we aren&rsquo;t doing any error-checking here.
Are we?
We just <em>bind</em> the values of <code>x</code> and <code>y</code>, then use these bindings as if they&rsquo;re regular old <code>Int</code>s.
Now, to see why this works, let&rsquo;s take a look at <code>Monad</code>&rsquo;s implementation.
The first step is to get rid of the <code>do</code> notation we were using.
The compiler removes it, so let&rsquo;s give it a go.</p>
<p>If I may, I&rsquo;d like to coin a phrase for using monadic computations without the <em>sugar</em> of <code>do</code> notation:</p>
<h2 id=warhead-monadic-style>Warhead monadic style</h2>
<p>If you don&rsquo;t know what <a href=http://warheads.com/>warheads</a> are, shame on you.
Anyway, as many monad tutorials will tell you, the desugared (sour) version of <code>z</code> looks like this:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=nf>z</span> <span class=ow>=</span> <span class=n>x</span> <span class=o>&gt;&gt;=</span> <span class=p>(</span><span class=nf>\</span><span class=n>x&#39;</span> <span class=ow>-&gt;</span>
    <span class=n>y</span> <span class=o>&gt;&gt;=</span> <span class=p>(</span><span class=nf>\</span><span class=n>y&#39;</span> <span class=ow>-&gt;</span>
    <span class=n>return</span> <span class=p>(</span><span class=n>x&#39;</span> <span class=o>+</span> <span class=n>y&#39;</span><span class=p>)))</span>
</code></pre></div><p>(Again, the parentheses are unnecessary - they&rsquo;re just there to show you where the lambdas begin and end.)</p>
<p>Once you wrap your mind around the parentheses and lambdas, the code becomes fairly simple.
Each <code>>>=</code> (bind) takes a <code>Maybe Int</code> on the left, and a function on the right to perform on the bound value.</p>
<p>So how does this let us seemingly ignore the <code>Nothing</code>s?
Let&rsquo;s check out the instance declatation for <code>Monad (Maybe a)</code>:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=kr>instance</span> <span class=kt>Monad</span> <span class=p>(</span><span class=kt>Maybe</span> <span class=n>a</span><span class=p>)</span> <span class=kr>where</span>
    <span class=kt>Just</span> <span class=n>x</span>  <span class=o>&gt;&gt;=</span> <span class=n>f</span>  <span class=ow>=</span> <span class=n>f</span> <span class=n>x</span>
    <span class=kt>Nothing</span> <span class=o>&gt;&gt;=</span> <span class=kr>_</span>  <span class=ow>=</span> <span class=kt>Nothing</span>
    <span class=n>return</span> <span class=n>x</span> <span class=ow>=</span> <span class=kt>Just</span> <span class=n>x</span>
</code></pre></div><p>So, let&rsquo;s evaluate our expression with <code>x = Just 5</code> and <code>y = Nothing</code>:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=nf>z</span> <span class=ow>=</span> <span class=kt>Just</span> <span class=mi>5</span>  <span class=o>&gt;&gt;=</span> <span class=p>(</span><span class=nf>\</span><span class=n>x&#39;</span> <span class=ow>-&gt;</span>
    <span class=kt>Nothing</span> <span class=o>&gt;&gt;=</span> <span class=p>(</span><span class=nf>\</span><span class=n>y&#39;</span> <span class=ow>-&gt;</span>
    <span class=n>return</span> <span class=p>(</span><span class=n>x&#39;</span> <span class=o>+</span> <span class=n>y&#39;</span><span class=p>)))</span>
</code></pre></div><p>Using the first pattern in the definition of <code>>>=</code>, we can reduce the first lambda, replacing <code>x'</code> with <code>5</code>:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=nf>z</span> <span class=ow>=</span> <span class=kt>Nothing</span> <span class=o>&gt;&gt;=</span> <span class=p>(</span><span class=nf>\</span><span class=n>y&#39;</span> <span class=ow>-&gt;</span>
    <span class=n>return</span> <span class=p>(</span><span class=mi>5</span> <span class=o>+</span> <span class=n>y&#39;</span><span class=p>))</span>
</code></pre></div><p>But now we have <code>Nothing >>= \y' -> ...</code> - which, as we know from the second pattern in <code>Maybe</code>&rsquo;s implementation of bind, will result in a <code>Nothing</code>:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=nf>z</span> <span class=ow>=</span> <span class=kt>Nothing</span>
</code></pre></div><p>So, in effect, the definition of <code>>>=</code> does the error-checking for us, ensuring that if we ever run into a <code>Nothing</code> value, the whole computation will end and give back <code>Nothing</code>.
And remember I said to notice the similarity between <code>Just (x' + y')</code> and <code>return (x' + y')</code> above?
Well look at that - for <code>Maybe</code>, <code>return</code> is the same as <code>Just</code>!
Isn&rsquo;t that great?
But you may still be dissatisfied.
Let&rsquo;s step beyond the world of monads to learn about another abstraction that will let us rewrite this in a one-liner.</p>
<h2 id=applicative-style>Applicative style</h2>
<p>You may have heard people throw around the term &lsquo;applicatives&rsquo;, or even - if you&rsquo;re astute - &lsquo;applicative functors&rsquo;.
Like monads, they&rsquo;re a fancy way of performing computations on things in boxes.
In this section, I&rsquo;ll be using <code>add</code> instead of <code>(+)</code> to keep down the amount of punctuation on each line.
Let&rsquo;s rewrite the above <code>Maybe</code> addition example in <em>applicative style</em>:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=kr>import</span> <span class=nn>Control.Applicative</span> <span class=p>(</span><span class=nf>pure</span><span class=p>,</span> <span class=p>(</span><span class=o>&lt;*&gt;</span><span class=p>))</span>
<span class=nf>z</span> <span class=ow>=</span> <span class=n>pure</span> <span class=n>add</span> <span class=o>&lt;*&gt;</span> <span class=n>x</span> <span class=o>&lt;*&gt;</span> <span class=n>y</span>
</code></pre></div><p>Don&rsquo;t be alarmed by the crazy operators.
I&rsquo;m not going to go into detail on this one, but what I want you to take away from this is a vague intuition for the syntax, and the equivalence between monadic and applicative operations.
We&rsquo;ve just done the same sort of thing as we did with monads - let the definition of <code>&lt;*></code> handle the <code>Nothing</code> cases for us.
<code>pure</code> is a lot like <code>fmap</code> - it turns <code>add</code> into a function that can operate on things in boxes.
Then <code>&lt;*></code> is used to apply arguments to this new box-aware function.</p>
<p>I&rsquo;ll tell you the truth - you don&rsquo;t often see <code>pure</code> in the wild.
Usually you see its cousin, <code>&lt;$></code>, a synonym for <code>fmap</code> that we can use in this situation.
It&rsquo;s called <code>&lt;$></code> to mirror the function application operator you&rsquo;re used to in regular pure Haskell, <code>$</code>.
And it works like this:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=kr>import</span> <span class=nn>Control.Applicative</span> <span class=p>((</span><span class=o>&lt;$&gt;</span><span class=p>),</span> <span class=p>(</span><span class=o>&lt;*&gt;</span><span class=p>))</span>
<span class=nf>z</span> <span class=ow>=</span> <span class=n>add</span> <span class=o>&lt;$&gt;</span> <span class=n>x</span> <span class=o>&lt;*&gt;</span> <span class=n>y</span>
</code></pre></div><p>Pow.</p>
<h2 id=do-you-even-lift-style>Do you even lift? style</h2>
<p>As I covered in my <a href=http://www.reddit.com/r/haskell/comments/1pd1ep/microtutorial_liftm_by_accident/><code>liftM</code> micro-tutorial</a>, <em>lifting</em> is a general way to make a function operate inside a monad.
In this case, since <code>(+)</code> has two arguments, we need the <code>liftM2</code> member of the family:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=kr>import</span> <span class=nn>Control.Monad</span> <span class=p>(</span><span class=nf>liftM2</span><span class=p>)</span>
<span class=nf>z</span> <span class=ow>=</span> <span class=n>liftM2</span> <span class=p>(</span><span class=o>+</span><span class=p>)</span> <span class=n>x</span> <span class=n>y</span>
</code></pre></div><p>Which, like <code>fmap</code> and like <code>pure</code>, we can think of as creating a new function, in this case a &lsquo;monadic&rsquo; one, of two arguments:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=nf>z</span> <span class=ow>=</span> <span class=n>liftedPlus</span> <span class=n>x</span> <span class=n>y</span>
    <span class=kr>where</span> <span class=n>liftedPlus</span> <span class=ow>=</span> <span class=n>liftM2</span> <span class=p>(</span><span class=o>+</span><span class=p>)</span>
</code></pre></div><p>Many people use <code>fmap</code> in preference to <code>liftM</code> as it doesn&rsquo;t require an import (and almost all <code>Monad</code>s are <code>Functors</code>), but there&rsquo;s no standard <code>fmap2</code> or higher orders defined (though you could easily do so yourself).
They can do this because most types that are <code>Monad</code>s are also <code>Functor</code>s.
In fact, mathematically they&rsquo;re related - it&rsquo;s just that not all types have an instance of both typeclasses.
(If you want to know - monads are a subset of the functors.)</p>
<h2 id=moving-swiftly-onwards>Moving swiftly onwards</h2>
<p>Ok, so now you&rsquo;re thoroughly able to add two <code>Maybe Int</code>s together in a myriad of ways.
Let&rsquo;s talk about another monad: lists.
I&rsquo;m going to assign you another arbitrary challenge: give me the Cartesian product of two lists.
That is, a list of tuples of every combination of the elements of the two lists.</p>
<p>Here&rsquo;s an example:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=nf>xs</span> <span class=ow>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>]</span>
<span class=nf>ys</span> <span class=ow>=</span> <span class=p>[</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>]</span>
<span class=nf>zs</span> <span class=ow>=</span> <span class=n>cartesian</span> <span class=n>xs</span> <span class=n>ys</span>
<span class=c1>-- zs == [(1, 3), (1, 4), (2, 3), (2, 4)]</span>
</code></pre></div><p>How would we do that in normal non-monadic code?
In an imperative language, you&rsquo;d probably write a nested <code>for</code> loop, which in Haskell usually means using <code>map</code>, like so:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=nf>cartesian</span> <span class=n>xs</span> <span class=n>ys</span> <span class=ow>=</span> <span class=n>concat</span> <span class=o>$</span> <span class=n>map</span> <span class=p>(</span><span class=nf>\</span><span class=n>x&#39;</span> <span class=ow>-&gt;</span> <span class=n>map</span> <span class=p>(</span><span class=nf>\</span><span class=n>y&#39;</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=n>x&#39;</span><span class=p>,</span> <span class=n>y&#39;</span><span class=p>))</span> <span class=n>ys</span><span class=p>)</span> <span class=n>xs</span>
</code></pre></div><p>Take a second to look that over.
(Also, ignore the obvious list-comprehension solution.
We&rsquo;ll get to that in a second.)
We <code>map</code> a function <code>\x'</code> over <code>xs</code> that <code>map</code>s a function <code>\y'</code> over <code>ys</code> and makes a tuple of the two elements <code>x'</code> (from the outer lambda) and <code>y'</code> (from the inner).
And we finally <code>concat</code> the whole lot so we end up with a flat list, rather than a list of lists of tuples.
This is looking suspiciously like our desugared warhead monadic code from above - all these lambdas and variables ending in <code>'</code>.
Well, to confirm your suspicions, let&rsquo;s rewrite this in a monad:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=nf>cartesian</span> <span class=n>xs</span> <span class=n>ys</span> <span class=ow>=</span> <span class=kr>do</span>
    <span class=n>x&#39;</span> <span class=ow>&lt;-</span> <span class=n>xs</span>
    <span class=n>y&#39;</span> <span class=ow>&lt;-</span> <span class=n>ys</span>
    <span class=n>return</span> <span class=p>(</span><span class=n>x&#39;</span><span class=p>,</span> <span class=n>y&#39;</span><span class=p>)</span>
</code></pre></div><p>This is almost identical to our monadic code when we used <code>Maybe</code>, except obviously we&rsquo;re making a tuple rather than adding the two bound elements.
How can this be?
How does <code>&lt;-</code> go from a list <code>xs</code> to a single value <code>x'</code>, and magically apply our computation over the whole of both lists?</p>
<p>Well again, we need to look into the definition of <code>>>=</code> for lists.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=kr>instance</span> <span class=kt>Monad</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=kr>where</span>
    <span class=n>xs</span> <span class=o>&gt;&gt;=</span> <span class=n>f</span> <span class=ow>=</span> <span class=n>concat</span> <span class=p>(</span><span class=n>map</span> <span class=n>f</span> <span class=n>xs</span><span class=p>)</span>
    <span class=n>return</span> <span class=n>x</span> <span class=ow>=</span> <span class=p>[</span><span class=n>x</span><span class=p>]</span>
</code></pre></div><p>The type of <code>>>=</code> for lists is <code>[a] -> (a -> [b]) -> [b]</code>.
<code>f</code> therefore has type <code>a -> [b]</code>, and mapping it over a <code>[a]</code> will produce a <code>[[b]]</code>, a list of list of <code>b</code>s, which is then flattened with <code>concat</code>.
I&rsquo;ll leave it to you to show how that is equivalent to our earlier <code>map</code>-filled definition of the Cartesian product.
Just convert the monadic computation to warhead style, and then start substituting!
(Note: you&rsquo;ll need to ask yourself what happens when I <code>concat</code> a list of single-element lists?
More specifically, what does <code>concat . map return</code> do?)</p>
<p>Unfortunately, at this point our nice metaphor of <code>fmap</code> and monads as computations that operate on &lsquo;things in boxes&rsquo; starts to break down.
Lists aren&rsquo;t really a value in a box - at best, they&rsquo;re many (or no) values in a box.
I&rsquo;ll leave that to more advanced tutorials on what monads and functors actually represent mathematically to explain.
For now, just understand that members of the <code>Monad</code> typeclass (or <code>Functor</code> when we&rsquo;re talking about <code>fmap</code>, or <code>Applicative</code> for applicatives) behave in certain ways depending on the definition of <code>>>=</code> and <code>return</code> they have given.</p>
<p>(You may be suspicious that I contrived my Cartesian product example to fit the definition of list&rsquo;s bind function.
Well, you&rsquo;re right.
So sue me!
I needed easy examples.)</p>
<h2 id=list-applicative-style>List applicative style</h2>
<p>Let&rsquo;s quickly revisit the applicative kingdom and rewrite our monadic function as an applicative one-liner.
Any guesses as to what it will look like?
Again, I&rsquo;ll use <code>tuple</code>, a function of two arguments, instead of the usual <code>(,)</code> operator to reduce line noise:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=nf>cartesian</span> <span class=n>xs</span> <span class=n>ys</span> <span class=ow>=</span> <span class=n>pure</span> <span class=n>tuple</span> <span class=o>&lt;*&gt;</span> <span class=n>xs</span> <span class=o>&lt;*&gt;</span> <span class=n>ys</span>
</code></pre></div><p>Or, as you&rsquo;ll see it in the wild:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=nf>cartesian</span> <span class=n>xs</span> <span class=n>ys</span> <span class=ow>=</span> <span class=n>tuple</span> <span class=o>&lt;$&gt;</span> <span class=n>xs</span> <span class=o>&lt;*&gt;</span> <span class=n>ys</span>
</code></pre></div><p>Mind = blown.
As above, I won&rsquo;t go into the details of this syntax.
If you&rsquo;re keen, look up the definitions of <code>&lt;*></code> and <code>&lt;$></code> in <code>Control.Applicative</code> and try to reduce these expressions yourself.
Here, I just want to expose you to the syntax.</p>
<h2 id=map-and-fmap>map and fmap</h2>
<p>Forgive me as I make a brief roadside stop to ask: what does this code do?</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=nf>fmap</span> <span class=p>(</span><span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span>
</code></pre></div><p>Try it out in GHCi.
Does that behavior look oddly familiar?
Of course - it&rsquo;s the same as <code>map</code>!
For historical reasons, we&rsquo;ve ended up with <code>map</code> being a list-specific function and <code>fmap</code> being its more general cousin that works for all <code>Functor</code>s.
In fact, <code>fmap</code> for lists is defined as <code>map</code>:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=kr>instance</span> <span class=kt>Functor</span> <span class=kt>[]</span> <span class=kr>where</span>
    <span class=n>fmap</span> <span class=n>f</span> <span class=n>xs</span> <span class=ow>=</span> <span class=n>map</span> <span class=n>f</span> <span class=n>xs</span>
</code></pre></div><p>I&rsquo;d have preferred it differently, but you can&rsquo;t have everything in this life.
But hey, you know what else is the same as <code>map</code>?</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=nf>liftM</span> <span class=p>(</span><span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span>
</code></pre></div><p>Yup.</p>
<h2 id=comprehensions>Comprehensions</h2>
<p>You might have spotted the easy solution to the cartesian product problem - a list comprehension.
To whit:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=nf>cartesian</span> <span class=n>xs</span> <span class=n>ys</span> <span class=ow>=</span> <span class=p>[(</span><span class=n>x&#39;</span><span class=p>,</span> <span class=n>y&#39;</span><span class=p>)</span> <span class=o>|</span> <span class=n>x&#39;</span> <span class=ow>&lt;-</span> <span class=n>xs</span><span class=p>,</span> <span class=n>y&#39;</span> <span class=ow>&lt;-</span> <span class=n>ys</span><span class=p>]</span>
</code></pre></div><p>But hang on - even <em>that</em> looks almost the same as our monadic solution, just all in one line!
In case you&rsquo;ve ever wondered why the <code>&lt;-</code> is used in monads as well as list comprehensions, now you know - they <em>are</em> the same!
In fact, let&rsquo;s take it a step further.
We can actually use comprehensions for any monad type!</p>
<h2 id=maybe-comprehension>Maybe comprehension</h2>
<p>In a special (ab?)use of syntax I like to call <em>lost in translation style</em>, we can perform a <code>Maybe</code> comprehension:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=cm>{-# LANGUAGE MonadComprehensions #-}</span>
<span class=nf>z</span> <span class=ow>=</span> <span class=p>[</span><span class=n>x&#39;</span> <span class=o>+</span> <span class=n>y&#39;</span> <span class=o>|</span> <span class=n>x&#39;</span> <span class=ow>&lt;-</span> <span class=n>x</span><span class=p>,</span> <span class=n>y&#39;</span> <span class=ow>&lt;-</span> <span class=n>y</span><span class=p>]</span>
</code></pre></div><p>Though we unfortunately have to enable a GHC extension to access general monad comprehensions, we can rewrite our <code>Maybe</code> addition code in one line without those funky applicative operators.</p>
<h2 id=final-remarks>Final remarks</h2>
<p>I hope you&rsquo;ve now gained a little bit of insight into why people talk about monads all the time when they talk about Haskell - they&rsquo;re a really powerful and pervasive way to abstract computation, and save ourselves some headache.
And hopefully, the next time you see a <code>&lt;*></code> or a <code>liftM</code> in somebody&rsquo;s code, you won&rsquo;t be too freaked out!
This tutorial has breezed over the <em>why</em> of monads and functors, so if you&rsquo;re after a more satisfying explanation,
I highly recommend LYAH&rsquo;s sections on <a href=http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass>functors</a>,
<a href=http://learnyouahaskell.com/functors-applicative-functors-and-monoids#functors-redux>more functors</a>,
<a href=http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors>applicatives</a>
and <a href=http://learnyouahaskell.com/a-fistful-of-monads>monads</a> (in that order).</p>
<p>Thanks for reading!</p>
</div>
<hr>
<p class=site-subtitle>fin</p>
</div>
</div>
</body>
</html>